(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{641:function(t,s,a){"use strict";a.r(s);var e=a(5),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"变量提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[t._v("#")]),t._v(" 变量提升")]),t._v(" "),a("p",[t._v("   函数在运行的时候，会首先创建执行上下文，然后将执行上下文入栈，然后当此执行上下文处于栈顶时，开始运行执行上下文。"),a("br"),t._v("\n   在创建执行上下文的过程中会做三件事：创建变量对象，创建作用域链，确定 this 指向，其中创建变量对象的过程中，首先会为 arguments 创建一个属性，值为 arguments，然后会扫码 function 函数声明，创建一个同名属性，值为函数的引用，接着会扫码 var 变量声明，创建一个同名属性，值为undefined，这就是变量提升。")]),t._v(" "),a("h2",{attrs:{id:"作用域和作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),a("ul",[a("li",[t._v("作用域：\nES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找作用域链")]),t._v(" "),a("li",[t._v("作用域链\n首先要了解作用域链，当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。")])]),t._v(" "),a("h2",{attrs:{id:"原型和原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),a("h3",{attrs:{id:"原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),a("ul",[a("li",[t._v("所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象")]),t._v(" "),a("li",[t._v("所有函数都有一个prototype(原型)属性，属性值是一个普通的对象")]),t._v(" "),a("li",[t._v("所有引用类型的__proto__属性指向它构造函数的prototype")])]),t._v(" "),a("h3",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),a("p",[t._v("   当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构。知道")]),t._v(" "),a("ol",[a("li",[t._v("一直往上层查找，直到到null还没有找到，则返回undefined")]),t._v(" "),a("li",[a("code",[t._v("Object.prototype.__proto__ === null")])]),t._v(" "),a("li",[t._v("所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象")])]),t._v(" "),a("h2",{attrs:{id:"new-一个函数发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-一个函数发生了什么"}},[t._v("#")]),t._v(" new 一个函数发生了什么")]),t._v(" "),a("p",[t._v("构造调用：")]),t._v(" "),a("ul",[a("li",[t._v("隐式创建一个空对象")]),t._v(" "),a("li",[t._v("这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象")]),t._v(" "),a("li",[t._v("这个新对象会绑定到函数调用的 this")]),t._v(" "),a("li",[t._v("如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象")])]),t._v(" "),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("   闭包是指有权访问另外一个函数作用域中的变量的函数JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建")]),t._v(" "),a("h2",{attrs:{id:"事件循环机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制"}},[t._v("#")]),t._v(" 事件循环机制")]),t._v(" "),a("p",[t._v("   事件循环机制从整体上告诉了我们 JavaScript 代码的执行顺序 Event Loop 即事件循环，是指浏览器或Node 的一种解决 javaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。"),a("br"),t._v("\n   先执行宏任务队列，然后执行微任务队列，然后开始下一轮事件循环，继续先执行宏任务队列，再执行微任务队列。")]),t._v(" "),a("ul",[a("li",[t._v("宏任务：script/setTimeout/setInterval/setImmediate/ I/O / UI Rendering")]),t._v(" "),a("li",[t._v("微任务：process.nextTick()/Promise\n上诉的 setTimeout 和 setInterval 等都是任务源，真正进入任务队列的是他们分发的任务。")])]),t._v(" "),a("p",[a("strong",[t._v("优先级：")])]),t._v(" "),a("ul",[a("li",[t._v("setTimeout = setInterval 一个队列")]),t._v(" "),a("li",[t._v("setTimeout > setImmediate")]),t._v(" "),a("li",[t._v("process.nextTick > Promise")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" macroTask "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" macroTaskQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMacroTask")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" microTask "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" microTaskQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleMicroTask")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("microTask"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);