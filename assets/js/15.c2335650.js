(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{614:function(s,t,a){"use strict";a.r(t);var e=a(5),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"一-同源策列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-同源策列"}},[s._v("#")]),s._v(" 一 同源策列")]),s._v(" "),a("p",[s._v("协议 域名 端口 相同就叫同源策略")]),s._v(" "),a("h2",{attrs:{id:"什么是跨域-怎么解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是跨域-怎么解决"}},[s._v("#")]),s._v(" 什么是跨域？怎么解决")]),s._v(" "),a("p",[s._v("总的来说就是因为浏览器的同源策略造成的，浏览器从用户的角度出发，如果说起请求或则传参到一个不同源的url就会不安全，JSONP可以解决但是有一个缺点，它只能用GET请求。CORS他允许浏览器向跨源服务器发出XMLHTTPREQUIEST请求，从而解决Ajax的短板，但是CORSA需要浏览器服务器同时支持，IE不能低于10。还可使用Websocket和Node代理，具体知道了（一般来说都是后端写，后端就一代码的事，我们前端解决就会麻烦点， 从用户和代码量来看都是不太好的）")]),s._v(" "),a("h2",{attrs:{id:"二-json是怎么解决跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-json是怎么解决跨域"}},[s._v("#")]),s._v(" 二 JSON是怎么解决跨域？")]),s._v(" "),a("ul",[a("li",[s._v("什么是跨域？\n"),a("ol",[a("li",[s._v("域名不同 （IP地址不同）")]),s._v(" "),a("li",[s._v("域名相同 （IP地址相同，端口不同）")])])]),s._v(" "),a("li",[s._v("跨域的问题：\n"),a("ul",[a("li",[s._v("浏览器存在限制，不让访问数据。而不是服务器限制，服务器正常发送请求，也正常响应了，但是当数据到达浏览器，浏览器不让Js去拿这些数据。此时以上Ajax\n的方案就起不到作用。")])])]),s._v(" "),a("li",[s._v("处理：\n"),a("ul",[a("li",[s._v("方案：JSONP")]),s._v(" "),a("li",[s._v("原理：利用script标签，加载src路径，实现跨域加载js文件，该js文件中需要定义好一个方法，将该方法名传递给服务端，服务端根据该方法名，拼接一个方法调用语句，响应给浏览器，用浏览器来执行该语句调用方法。通过参数，将响应的数据取出即可。")])])]),s._v(" "),a("li",[s._v("实现：\n"),a("ul",[a("li",[s._v("js:\n"),a("ol",[a("li",[s._v("定义一个方法，script加载")]),s._v(" "),a("li",[s._v("取方法中参数，进行业务处理。")]),s._v(" "),a("li",[s._v("哟用ajax请求数据的时候有一个参数dataType可以填jsonp")])])])])])]),s._v(" "),a("h2",{attrs:{id:"三-配置代理解决跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-配置代理解决跨域"}},[s._v("#")]),s._v(" 三 配置代理解决跨域")]),s._v(" "),a("p",[s._v("在config中的index.js里有个proxyTable")]),s._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[s._v("proxyTable"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"/baidu"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//关键字")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"target"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"目标域名地址"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"changeOrigin"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 允许跨域")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"pathRewritr"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 路径重写规则【可选】目的就是地址有没有关键词")]),s._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[s._v('"/baidu"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('""')]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h2",{attrs:{id:"四-ajax和axios"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-ajax和axios"}},[s._v("#")]),s._v(" 四 Ajax和axios")]),s._v(" "),a("ul",[a("li",[s._v("区别：axios是通过Promise实现对Ajax技术的一种封装，就像jQuery实现Ajax封装一样，简单来说Ajax技术实现了网页的局部数据刷新，axios实现了对Ajax的封装。axios是Ajax，Ajax不知axios。")]),s._v(" "),a("li",[s._v("优缺点：\n"),a("ul",[a("li",[s._v("Ajax：本身是针对MVC的编程，不符合现在前端MVVM的浪潮。基于原生的XHR开发，XHR本身的架构不清晰，已经有了Fetch的替代方案jQuery整个项目太大，单纯使用Ajax却要引入整个jQuery非常不合理（采取个性化打包的方案又不能享受CDN服务）")]),s._v(" "),a("li",[s._v("axios：\n"),a("ul",[a("li",[s._v("从node.js创建http请求")]),s._v(" "),a("li",[s._v("支持Promise")]),s._v(" "),a("li",[s._v("客户端支持防止CSRF")]),s._v(" "),a("li",[s._v("提供了一些并发请求的接口（重要，方便了很多操作）")])])])])])]),s._v(" "),a("h2",{attrs:{id:"五-http和https的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五-http和https的区别"}},[s._v("#")]),s._v(" 五 Http和Https的区别")]),s._v(" "),a("ol",[a("li",[s._v("http是明文传输，https则是ssl加密传世。更安全。")]),s._v(" "),a("li",[s._v("http和https是完全不同的链接方式，端口也不一样http是80 https是443")])]),s._v(" "),a("h2",{attrs:{id:"六-三次握手和四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六-三次握手和四次挥手"}},[s._v("#")]),s._v(" 六 三次握手和四次挥手")]),s._v(" "),a("ul",[a("li",[s._v("三次握手：\n"),a("ol",[a("li",[s._v("首先client端向server端发送SYN请求报文\n"),a("ul",[a("li",[s._v("此时client从关闭状态变成了发送（SYN-sent）状态。")]),s._v(" "),a("li",[s._v("server端从关闭状态变成了监听状态（LIsten）状态。")])])]),s._v(" "),a("li",[s._v("server接受链接并回复ACK确认报文，并为这次链接分配资源\n"),a("ul",[a("li",[s._v("server从listen状态切换为回复（SYN-recvd）状态。")])])]),s._v(" "),a("li",[s._v("client接受ACK报文后也会向serverACK确认报文\n"),a("ul",[a("li",[s._v("当client收到server的响应时状态就切换成稳定链接状态。")]),s._v(" "),a("li",[s._v("server在第二次接受到client的数据也切换成稳定链接状态。")])])])])]),s._v(" "),a("li",[s._v("四次挥手：\n"),a("ol",[a("li",[s._v("首先client向server递交结束请求FIN报文\n"),a("ul",[a("li",[s._v("client从稳定链接状态改为等待结束（FIN_WAIT_1）")]),s._v(" "),a("li",[s._v("server收到请求从稳定链接状态后改为等待关闭（CLOSE_WAIT）")])])]),s._v(" "),a("li",[s._v("server收到请求报文后随即回复确认ACK报文并且让client等待")]),s._v(" "),a("li",[s._v("server再次向client发送FIN结束报文\n"),a("ul",[a("li",[s._v("server发送完FIN报文状态就变成了LAST_ACK（最后等待确认）")])])]),s._v(" "),a("li",[s._v("client收到了server发来的FIN结束报文随即就向server发送确认报文双方变为关闭状态。")])])])]),s._v(" "),a("h2",{attrs:{id:"七-常用状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七-常用状态码"}},[s._v("#")]),s._v(" 七 常用状态码")]),s._v(" "),a("ul",[a("li",[s._v("200 成功")]),s._v(" "),a("li",[s._v("302 重定向")]),s._v(" "),a("li",[s._v("304 未修改（重复请求）")]),s._v(" "),a("li",[s._v("400 服务器不理解的语法")]),s._v(" "),a("li",[s._v("403 服务器拒绝请求")]),s._v(" "),a("li",[s._v("404 找不到服务器")]),s._v(" "),a("li",[s._v("500 服务器错了")])]),s._v(" "),a("h2",{attrs:{id:"八-websocket协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八-websocket协议"}},[s._v("#")]),s._v(" 八 websocket协议")]),s._v(" "),a("p",[s._v("我们平常使用http有个缺陷：通信只能由客户端发起，做不到服务端向客户端推送消息。这就注定了如果服务器有连续的状态变化，我们只能用轮询（每隔一段时间发一个询问），但是轮询的效率是无故的，非常浪费资源，于是websoket就发明了，他最大的特点就是服务器可以向客户端发送。websocket只需要一次握手就可建立链接，它的流程是：")]),s._v(" "),a("ol",[a("li",[s._v("client向server先发出握手请求叫做handshake")]),s._v(" "),a("li",[s._v("serve向client回应感谢Acknowledgement")]),s._v(" "),a("li",[s._v("建立双向链接Bi-directional messages")]),s._v(" "),a("li",[s._v("结束connection end")])]),s._v(" "),a("ul",[a("li",[s._v("和HTTP都是TCP协议之上的可以发送文本，也可发送二进制数据没有同源限制，客户端可以任意与服务器通信，readystate数据属性返回实例状态有四种：\n"),a("ul",[a("li",[s._v("connecting： 0 正在连接")]),s._v(" "),a("li",[s._v("open: 1 连接成功")]),s._v(" "),a("li",[s._v("closing： 2 正在关闭")]),s._v(" "),a("li",[s._v("closed： 3 连接已关闭")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);